<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Falcon.js | Structure for Knockout</title>
		
		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<link href="css/bootstrap.min.css" rel="stylesheet" />
		<link href="css/falcon.docs.min.css" rel="stylesheet" />

	</head>
	<body data-spy="scroll" data-target="#sidebar">
		<div id="content" class="container">
			<div id="hero">
				<div class="hero-headline">
					Falcon.js
				</div>
				<div class="hero-tagline">Structure for Knockout.js</div>
				<p class="hero-description">
					Falcon.js adds structure to knockout.js by incorporting
					<strong>models</strong>, 
					<strong>collections</strong>,
					and <strong>views</strong>.
					It's set up to make developing single-page web applications a breeze.
				</p>
				<div class="hero-actions">
					<a class="btn btn-danger">
						Download v0.6.3
						<small>
							Knockout.js 2.3.0 Included
						</small>
					</a>
				</div>
				</p>
			</div>
			<div class="row">
				<div class="col col-lg-3">
					<div id="sidebar" data-spy="affix" data-offset-top="499">
						<div id="sidebar-header">
							Falcon.js
							<a class="btn btn-xs btn-danger pull-right">
								Download v0.6.3
							</a>
						</div>
						<ul class="nav sidebar-nav">
							
							

<li>
	<a href="#getting_started" alt="Getting Started">Getting Started</a>
	<ul class="nav navbar-nav">
		
			
			
				<li>
					<a href="#getting_started-overview" alt="Overview">Overview</a>
				</li>
			
		
			
			
				<li>
					<a href="#getting_started-knockout_crash_course" alt="Knockout Crash Course">Knockout Crash Course</a>
				</li>
			
		
			
			
				<li>
					<a href="#getting_started-basic_todo_list" alt="Basic Todo List">Basic Todo List</a>
				</li>
			
		
			
			
				<li>
					<a href="#getting_started-multiple_todo_lists" alt="Multiple Todo Lists">Multiple Todo Lists</a>
				</li>
			
		
			
			
				<li>
					<a href="#getting_started-multiple_todo_lists_utilizing_remote_resources" alt="Multiple Todo Lists Utilizing Remote Resources">Multiple Todo Lists Utilizing Remote Resources</a>
				</li>
			
		
	</ul>
</li>

							<li class="nav-divider"></li>
							
							
							

<li>
	<a href="#model" alt="Model">Model</a>
	<ul class="nav navbar-nav">
		
			
			
				<li>
					<a href="#model-clone" alt="clone">clone</a>
				</li>
			
		
			
			
				<li>
					<a href="#model-initialize" alt="initialize">initialize</a>
				</li>
			
		
			
			
				<li>
					<a href="#model-copy" alt="copy">copy</a>
				</li>
			
		
			
			
				<li>
					<a href="#model-create" alt="create">create</a>
				</li>
			
		
			
			
				<li>
					<a href="#model-destroy" alt="destroy">destroy</a>
				</li>
			
		
			
			
				<li>
					<a href="#model-equals" alt="equals">equals</a>
				</li>
			
		
			
			
				<li>
					<a href="#model-extend" alt="extend">extend</a>
				</li>
			
		
			
			
				<li>
					<a href="#model-fetch" alt="fetch">fetch</a>
				</li>
			
		
			
			
				<li>
					<a href="#model-fill" alt="fill">fill</a>
				</li>
			
		
			
			
				<li>
					<a href="#model-get" alt="get">get</a>
				</li>
			
		
			
			
				<li>
					<a href="#model-id" alt="id">id</a>
				</li>
			
		
			
			
				<li>
					<a href="#model-isnew" alt="isNew">isNew</a>
				</li>
			
		
			
			
				<li>
					<a href="#model-makeurl" alt="makeUrl">makeUrl</a>
				</li>
			
		
			
			
				<li>
					<a href="#model-mixin" alt="mixin">mixin</a>
				</li>
			
		
			
			
				<li>
					<a href="#model-parent" alt="parent">parent</a>
				</li>
			
		
			
			
				<li>
					<a href="#model-parse" alt="parse">parse</a>
				</li>
			
		
			
			
				<li>
					<a href="#model-save" alt="save">save</a>
				</li>
			
		
			
			
				<li>
					<a href="#model-serialize" alt="serialize">serialize</a>
				</li>
			
		
			
			
				<li>
					<a href="#model-set" alt="set">set</a>
				</li>
			
		
			
			
				<li>
					<a href="#model-sync" alt="sync">sync</a>
				</li>
			
		
			
			
				<li>
					<a href="#model-toggle" alt="toggle">toggle</a>
				</li>
			
		
			
			
				<li>
					<a href="#model-unwrap" alt="unwrap">unwrap</a>
				</li>
			
		
			
			
				<li>
					<a href="#model-url" alt="url">url</a>
				</li>
			
		
			
			
				<li>
					<a href="#model-validate" alt="validate">validate</a>
				</li>
			
		
	</ul>
</li>
							
							
							

<li>
	<a href="#collection" alt="Collection">Collection</a>
	<ul class="nav navbar-nav">
		
			
			
				<li>
					<a href="#collection-all" alt="all">all</a>
				</li>
			
		
			
			
				<li>
					<a href="#collection-any" alt="any">any</a>
				</li>
			
		
			
			
				<li>
					<a href="#collection-append" alt="append">append</a>
				</li>
			
		
			
			
				<li>
					<a href="#collection-at" alt="at">at</a>
				</li>
			
		
			
			
				<li>
					<a href="#collection-clone" alt="clone">clone</a>
				</li>
			
		
			
			
				<li>
					<a href="#collection-initialize" alt="initialize">initialize</a>
				</li>
			
		
			
			
				<li>
					<a href="#collection-copy" alt="copy">copy</a>
				</li>
			
		
			
			
				<li>
					<a href="#collection-create" alt="create">create</a>
				</li>
			
		
			
			
				<li>
					<a href="#collection-destroy" alt="destroy">destroy</a>
				</li>
			
		
			
			
				<li>
					<a href="#collection-each" alt="each">each</a>
				</li>
			
		
			
			
				<li>
					<a href="#collection-extend" alt="extend">extend</a>
				</li>
			
		
			
			
				<li>
					<a href="#collection-fetch" alt="fetch">fetch</a>
				</li>
			
		
			
			
				<li>
					<a href="#collection-fill" alt="fill">fill</a>
				</li>
			
		
			
			
				<li>
					<a href="#collection-first" alt="first">first</a>
				</li>
			
		
			
			
				<li>
					<a href="#collection-last" alt="last">last</a>
				</li>
			
		
			
			
				<li>
					<a href="#collection-length" alt="length">length</a>
				</li>
			
		
			
			
				<li>
					<a href="#collection-makeurl" alt="makeUrl">makeUrl</a>
				</li>
			
		
			
			
				<li>
					<a href="#collection-mixin" alt="mixin">mixin</a>
				</li>
			
		
			
			
				<li>
					<a href="#collection-model" alt="model">model</a>
				</li>
			
		
			
			
				<li>
					<a href="#collection-models" alt="models">models</a>
				</li>
			
		
			
			
				<li>
					<a href="#collection-parent" alt="parent">parent</a>
				</li>
			
		
			
			
				<li>
					<a href="#collection-parse" alt="parse">parse</a>
				</li>
			
		
			
			
				<li>
					<a href="#collection-pluck" alt="pluck">pluck</a>
				</li>
			
		
			
			
				<li>
					<a href="#collection-pop" alt="pop">pop</a>
				</li>
			
		
			
			
				<li>
					<a href="#collection-prepend" alt="prepend">prepend</a>
				</li>
			
		
			
			
				<li>
					<a href="#collection-push" alt="push">push</a>
				</li>
			
		
			
			
				<li>
					<a href="#collection-remove" alt="remove">remove</a>
				</li>
			
		
			
			
				<li>
					<a href="#collection-reset" alt="reset">reset</a>
				</li>
			
		
			
			
				<li>
					<a href="#collection-serialize" alt="serialize">serialize</a>
				</li>
			
		
			
			
				<li>
					<a href="#collection-shift" alt="shift">shift</a>
				</li>
			
		
			
			
				<li>
					<a href="#collection-slice" alt="slice">slice</a>
				</li>
			
		
			
			
				<li>
					<a href="#collection-sort" alt="sort">sort</a>
				</li>
			
		
			
			
				<li>
					<a href="#collection-sync" alt="sync">sync</a>
				</li>
			
		
			
			
				<li>
					<a href="#collection-unshift" alt="unshift">unshift</a>
				</li>
			
		
			
			
				<li>
					<a href="#collection-unwrap" alt="unwrap">unwrap</a>
				</li>
			
		
			
			
				<li>
					<a href="#collection-url" alt="url">url</a>
				</li>
			
		
			
			
				<li>
					<a href="#collection-without" alt="without">without</a>
				</li>
			
		
	</ul>
</li>
							
							
							

<li>
	<a href="#view" alt="View">View</a>
	<ul class="nav navbar-nav">
		
			
			
				<li>
					<a href="#view-addchildview" alt="addChildView">addChildView</a>
				</li>
			
		
			
			
				<li>
					<a href="#view-cachetemplate" alt="cacheTemplate">cacheTemplate</a>
				</li>
			
		
			
			
				<li>
					<a href="#view-initialize" alt="initialize">initialize</a>
				</li>
			
		
			
			
				<li>
					<a href="#view-display" alt="display">display</a>
				</li>
			
		
			
			
				<li>
					<a href="#view-dispose" alt="dispose">dispose</a>
				</li>
			
		
			
			
				<li>
					<a href="#view-is_loaded" alt="is_loaded">is_loaded</a>
				</li>
			
		
			
			
				<li>
					<a href="#view-makeurl" alt="makeUrl">makeUrl</a>
				</li>
			
		
			
			
				<li>
					<a href="#view-render" alt="render">render</a>
				</li>
			
		
			
			
				<li>
					<a href="#view-resetcache" alt="resetCache">resetCache</a>
				</li>
			
		
			
			
				<li>
					<a href="#view-template" alt="template">template</a>
				</li>
			
		
			
			
				<li>
					<a href="#view-unrender" alt="unrender">unrender</a>
				</li>
			
		
			
			
				<li>
					<a href="#view-url" alt="url">url</a>
				</li>
			
		
			
			
				<li>
					<a href="#view-viewmodel" alt="viewModel">viewModel</a>
				</li>
			
		
	</ul>
</li>
							
							
							

<li>
	<a href="#helpers" alt="Helpers">Helpers</a>
	<ul class="nav navbar-nav">
		
			
			
				<li>
					<a href="#helpers-addbinding" alt="addBinding">addBinding</a>
				</li>
			
		
			
			
				<li>
					<a href="#helpers-apply" alt="apply">apply</a>
				</li>
			
		
			
			
				<li>
					<a href="#helpers-iscollection" alt="isCollection">isCollection</a>
				</li>
			
		
			
			
				<li>
					<a href="#helpers-isdataobject" alt="isDataObject">isDataObject</a>
				</li>
			
		
			
			
				<li>
					<a href="#helpers-isfalconobject" alt="isFalconObject">isFalconObject</a>
				</li>
			
		
			
			
				<li>
					<a href="#helpers-ismodel" alt="isModel">isModel</a>
				</li>
			
		
			
			
				<li>
					<a href="#helpers-isview" alt="isView">isView</a>
				</li>
			
		
	</ul>
</li>
							
							
							

<li>
	<a href="#bindings" alt="Bindings">Bindings</a>
	<ul class="nav navbar-nav">
		
			
			
				<li>
					<a href="#bindings-foreach" alt="foreach">foreach</a>
				</li>
			
		
			
			
				<li>
					<a href="#bindings-log" alt="log">log</a>
				</li>
			
		
			
			
				<li>
					<a href="#bindings-options" alt="options">options</a>
				</li>
			
		
			
			
				<li>
					<a href="#bindings-view" alt="view">view</a>
				</li>
			
		
	</ul>
</li>

							<li class="nav-divider"></li>

							<li>
								<a href="/tests/index.html" alt="Tests" target="_blank">Tests</a>
							</li>

							<li>
								<a href="http://knockoutjs.com/" alt="Knckout.js Homepage" target="_blank">Knockout.js</a>
							</li>
						</ul>
					</div>
				</div>
				<div id="main" class="col col-lg-9">
					


<section id="getting_started">
	<div class="page-header">
		<h1>Getting Started</h1>
	</div>
	
		
			
			<h3 id="getting_started-overview">Overview
				<small></small>
			</h3>
			
		
	
		
			
			<h3 id="getting_started-knockout_crash_course">Knockout Crash Course
				<small></small>
			</h3>
			<p>
	Before getting started with Falcon, we'll need to run briefly through how <a href="http://knockoutjs.com/">Knockout.js</a> works. If you already have a decent understanding of general Knockout concepts, feel free to skip this portion of the tutorial and get started with our <a href="#getting_started-basic_todo_list">Basic Todo List example</a>.  Additionally, if you're looking for more information on Knockout, be sure to check out their <a href="http://learn.knockoutjs.com/">interactive tutorial</a> and <a href="http://knockoutjs.com/documentation/introduction.html">documentation</a>.  Nevertheless, let's get started.
</p>
<h4>What is Knockout?</h4>
<p>
	<a href="http://knockoutjs.com/">Knockout.js</a> is a Javascript library that provides a Model View ViewModel (MVVM) architecture for web applications. Essentially, it allows DOM elements to be dynamically updated and re-rendered when certain variables are updated without creating a hard dependency between your Javascript and HTML. In other words, Knockout allows us to update a value in Javascript and then have all of the related HTML elements (think form fields, paragraphs, css classes, etc.) update and re-rendered when neeeded.
</p>
<h4>Observables and Bindings</h4>
<p>
	To begin we'll need to understand the two most core concepts of Knockout: <strong>Observables</strong> and <strong>Bindings</strong>.
</p>
<p>
	<strong>Observables</strong> are Knockout's form of variables that are meant to hold and update data. An observable is created like so: <code>var myVariable = ko.observable()</code>.  Each observable that you create returns an overloaded method that can be used to read/write data to/from the observable. For clairty, here's how you read data <code>myVariable()</code> and write data <code>myVariable("Hello World")</code> to an observable.
</p>
<p>
	<strong>Bindings</strong> are the functions that Knockout uses to link observables with HTML elements.  Essentially it's how Knockout links your javascript and HTML. Bindings on an HTML element are defined by a custom attribute <code>data-bind=""</code>.  Here's just a few examples of what bindings can be used for:
	<ul>
		<li>Reading and writing data between an HTML input field and an observable.</li>
		<li>Output text or html from an observable to a span field.</li>
		<li>Toggling a css class on an element when an observable that is truthy or falsey.</li>
		<li>Calling certain Javascript functions when an event is trigged on an element.</li>
	</ul>
	Additionally, it's possible to create your own, custom bindings, but we won't discuss that in these early tutorials. If you're interested in learning now, take a look at the <a href="http://knockoutjs.com/documentation/custom-bindings.html">Knockout documentation for custom bindings</a>.
</p>
<p>
	Take a look at the jsFiddle example below.  Here we're creating an observable 'name' on a viewModel object. We're setting the name to 'Mr. Falcon' and then applying the bindings to our html. <code>ko.applyBindings( viewModel )</code> is how we initialize Knockout and tell it to parse through our html to link bindings with the specified viewModel.
</p>
<p>
	In the HTML tab of the jsFiddle you'll see our Knockout template. Here we have an input text field that will update the value of our 'name' observable using the 'value' binding when the text field's value is changed. Once the 'name' observable is updated, Knockout will also update the text in the 'span' element via the 'text' bindings. Take a look at the result tab to see how this works.
</p>
<iframe width="100%" height="200" src="http://jsfiddle.net/stoodder/yusbY/embedded/js,html,result/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<h4>Computed Observables</h4>
<p>
	In this next example we'll talk about <strong>Computed Observables</strong>. Computed observables are essentially calculated values based on other observables or computed observables. Computed observables can be created like so: <code>var myComputeObservable = ko.computed(function(){...})</code>.  The function that is defined in the computed should return the calculated value of the observable. If we've read any observable values from within the function then whenever that observable is updated, the computed observable will also be recalculated.
</p>
<p>
	For instance, in the example below we have two observables that represent a first and last name of a user. We also have a computed observable called 'full_name' that will output the full name representation of whatever the user has entered for their first and last names. In the example, we've bound two input fields via the 'value' binding to the first and last name bindings. We then bind the 'full_name' computed observable to the text binding of the span field which will output the full name. Notice also that we've introduced the 'if' binding around our text output of the full name. The 'if' binding is used to either display or hide children elements based on the truthy or falsey value of an observable. Take a look at the result tab of the jsFiddle to see how this works.
</p>
<iframe width="100%" height="300" src="http://jsfiddle.net/stoodder/VGjV8/embedded/js,html,result/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<h4>Writeable Computed Observables and Virtual Bindings</h4>
<p>
	In the previous example we created a computed observable that simply calculated and outputted a specific value. However, it is possible to also write to a computed observable as well.  In this example, we'll be introducing <strong>Writeable Observables</strong> and <strong>Virtual Bindings</strong> (which is just fancy terminology for bindings that use HTML comment notation instead of the data-bind="" attribute).
</p>
<p>
	In this example we update the 'full_name' computed binding to also become writeable. In our template, we've added another field that allows users to type in their full name (instead of just their first and last names). When the value of that field changes the writeable observable splits the name properly and re-updates the first and last name values. Additionally, we've changed our template to now use Virtual Bindings rather than depending on HTML elements for certain things. The virtual bindings can be found in the form of HTML comments that take this pattern: <code>&lt;!-- ko binding: observable -->Content...&lt;!-- /ko --></code>. Take a look at the example below to see how this works:
</p>
<iframe width="100%" height="500" src="http://jsfiddle.net/stoodder/MH3vq/embedded/js,html,result/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>


<h4>Observable Arrays, Event Bindings, and Binding Contexts</h4>
<p>
	Lastly, we'll discuss 3 other topics that should be understood before diving in to Falcon: <strong>Observable Arrays</strong>, <strong>Event Bindings</strong>, and <strong>Binding Contexts</strong>.  In this example we'll let a user enter a first and last name of a person and add their name to a list of people. The user will also have the ability to remove specific names from the list of names.
</p>
<p>
	<strong>Observable Arrays</strong> are just observables that hold an array of data. They are useful for updating lists and only re-rendring specific elements within the list upon, addition, change, removal, or movement of elements within the array.  In this example, then 'names' observable array will hold a list of name objects.  Each name object has an auto-incrementing index and a person's full name.
</p>
<p>
	Also in this example we have two methods, 'addName' and 'removeName', that will be bound to buttons with the 'click' binding. The click binding is an example of an <strong>event binding</strong>. With the 'click' binding, the current template context will be passed in as the first argument.  In other words, when using the 'foreach' binding on the 'names' observables array, a list of names is displayed to the user with a 'remove' button next to each. Each remove button is bound to the 'removeName' function on the viewModel through the 'click' binding. When a user clicks the remove button, that specific name object is passed into the 'removeName' function as the first argument.
</p>
	Finally, if you look at how the 'removeName' function is bound to the 'click' binding in the html tab of the jsFiddle you'll see that we use <code>click: $root.removeName</code>. In Knockout, $root is called a <strong>Binding Context</strong>.  Essentially, binding contexts are just variables that can be used in templates to help us navigate to different parts of the context hierarchy.  In other words, the $root context always references the root viewModel that is bound with ko.applyBindings(). In our example we needed to use the $root binding from within the foreach binding because the current context would be that of each individual name object rather than the root view model. Other binding contexts include: $root, $parent, $parents, $data and more. To learn about them in-depth, checkout the <a href="http://knockoutjs.com/documentation/binding-context.html">Knockout Docs on Binding Contexts</a>.
<p>
	</p>
<iframe width="100%" height="500" src="http://jsfiddle.net/stoodder/T3Q38/embedded/js,html,result/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
		
	
		
			
			<h3 id="getting_started-basic_todo_list">Basic Todo List
				<small></small>
			</h3>
			<p>
	In this first example of Falcon, we'll run through the traditional basic todo list.  Here you'll see how Falcon can be used to add, remove, and complete todos on a todo list. This also allows us to edit the title and description of the todo list.  In these examples, I've written comments around areas of interest describing how everything is working in the code. Be sure to look through all of the tabs in the jsFiddle to get a full understanding of everything.
</p>
<p>
	A few key things to pay attention for are <strong>Models</strong>, <strong>Collections</strong>, <strong>Views</strong>, the <strong>Falcon.apply()</strong> method, and the <strong>$view</strong> binding context (in the html template).
</p>
<ul>
	<li>
		<strong>Model</strong> - Represents a single object (such as an Animal, Automobile, or a single Todo)
	</li>
	<li>
		<strong>Collection</strong> - Represents a list of models (such as an Animals, Automobiles, or multiple Todos)
	</li>
	<li>
		<strong>View</strong> - Handles the interaction between models, collections and other application logic and binds everything to a specified knockout template.
	</li>
	<li>
		<strong>Falcon.apply()</strong> - This is the single method that must be called to initialize Falcon and your app. The first argument must be a Falcon View that will be bound against, by default, the <code>&lt;body&gt;</code>  of the document. Optionally, you may pass in a second parameter to specify what element on the page we would like to initialize our application in. In this example we use the <code>#application</code> element.  This will trigger the specified view to load its html template and inject it into our app's container element.
	</li>
	<li>
		<strong>$view</strong> - This is a new binding context (like knockout's $root, $parent, and $data) added by Falcon to give your templates direct access to a view's methods and variables regardless of what scope you're currently in.  By default, the root level scope of a view's template is the view itself. However, if you're within a 'foreach' binding, then instead of having to call $parent to access the view, you can simply us $view itself.  To get a better understanding of how this is implemented, look at the html tab in the jsFiddle below.
	</li>
</ul>
<iframe width="100%" height="650" src="http://jsfiddle.net/stoodder/2ZX52/embedded/js,html,result/light/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
		
	
		
			
			<h3 id="getting_started-multiple_todo_lists">Multiple Todo Lists
				<small></small>
			</h3>
			<p>
	In this next example, we go a bit more complex with our application.Instead of letting users manage a single todo list, we've set it up so that users can have a list of multiple todo lists each with a title, description, and multiple todos.  The user is able to create new todo lists at will, edit that todo list, and remove the todo list. Different views will be presented to the user (create todo list form, view todo list, etc) within a general layout that will contain a list of all of the user's current todo lists.
</p>
<p>
	The point of this example is to show how Falcon allows for multiple views to be created and injected inside one-another (for example, like having a global layout with many different 'pages').  Also we show how Falcon implements an event messaging architecture to help pass messages and listen to events between objects.
</p>
<p>
	Some key things to look out for in this example are the <strong>on()</strong> method, the <strong>trigger()</strong> method, and the <strong>view</strong> binding (in the html tab of the jsFiddle).
</p>
<ul>
	<li>
		<strong>on()</strong> - Method used to listen to a specific event being fired on an object. For example, if a view triggered a custom 'edit' event, a different view could listen for the 'edit' event by using the 'on' method like so: <br/><code>view.on('edit', function(){ ... callback ... })</code><br/> The first argument of the 'on' method is that event that you would like to listen for and the second argument is the callback method that should be triggered whenever a specific event is encountered.  An optional third argument can be passed to this method which defined the context (the value of 'this') in which the callback method should be fire with.
	</li>
	<li>
		<strong>trigger()</strong> - Method used to send a custom event to any listeners (who used the 'on' method described above).  This method takes N number of arguments, where the first argument is the event that we would like to trigger and any additional arguments are variables that should be passed into any of the listener's callback methods.
	</li>
	<li>
		<strong>view binding</strong> - The view binding is a new binding added by Falcon that allows us to inject a view within another view. This binding takes in a Falcon View or a Knockout observable and injects the rendered view within the current view's rendered template. If an observable is given (like in our example), the child view will dynamically change whenever the observables is updated with a new view. An example of how this is used can be seen in the example's html tab within the '#layout_template' element.  This binding is useful for dynamic apps that have common widgets spread throughout them or with apps that have multiple hierarchies of views (such as with a todo list manager that has a layout with multiple pages and edit forms).
</ul>
<iframe width="100%" height="650" src="http://jsfiddle.net/stoodder/7rEax/embedded/js,html,result/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
		
	
		
			
			<h3 id="getting_started-multiple_todo_lists_utilizing_remote_resources">Multiple Todo Lists Utilizing Remote Resources
				<small></small>
			</h3>
			<p>
	In this final example, we take the previous multiple todo list example, and add a remote server to the mix.  Here we'll be loading and saving the view templates and model/collection data from a remote server.  Infact, we're actually using a mock javascript server with local storage. If you're curious to see how that works, the javascript can be found <a href="/scripts/mock_todo_server.js">here</a>.
</p>
<p>
	In this example we'll show how Falcon loads and caches view templates. We'll also demonstrate how Falcon's makeUrl method on views, models, and collections generate URLs and what it means for a model or a collection have a 'parent' model.
</p>
<iframe width="100%" height="650" src="http://jsfiddle.net/stoodder/G5XFT/embedded/js,html,result/light/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
		
	
</section>




<section id="model">
	<div class="page-header">
		<h1>Model</h1>
	</div>
	
		
			
			<h3 id="model-clone">clone
				<small>model.clone( [parent] )</small>
			</h3>
			<dl>
	<dt data-type="Falcon.Model">parent</dt>
	<dd>An optional parent to assign to the new clone. If 'null' is explicitly given, then the clone will not have a parent. If no parent is given, then by default, the new model inherits this model's parent.</dd>
</dl>
<p>
	Creates a clone of the current model. This method has the ability to also update the parent on the cloned model. If 'null' is explicitly given for the parent argument, then the cloned model will be parent-free.
</p>
		
	
		
			
			<h3 id="model-initialize">initialize
				<small>new Model( [data], [parent] )</small>
			</h3>
			<dl>
	<dt data-type="Object">data</dt>
	<dd>An object of initial data for this model</dd>
	<dt data-type="Falcon.Model">parent</dt>
	<dd>The object that 'owns' this model. This is used for generating urls in the 'makeUrl' function when syncing data between client and server.</dd>
</dl>
<p>
	The initialize method is called within the actual constructor method of the model. The constructor method has specific set up code that should alway be run when creating a model and hence, having the initialize method available, allows developers to override this funciton to ensure that everything that the actual constructor needs to do is executed prior to the initialize method and everything custom that the developer needs won't interfere with the required operations.
</p>
		
	
		
			
			<h3 id="model-copy">copy
				<small>model.copy( [attributes], [parent] )</small>
			</h3>
			<dl>
	<dt data-type="Object">attributes</dt>
	<dd>An object (or an array which will be converted to an object) of attributes to copy from this model to the new model. If this is not provided, only the id of this model is carried into the new model.</dd>
	<dt data-type="Falcon.Model">parent</dt>
	<dd> An override of the parent to set in the resultant model. If 'null' is explicitly given, then the resultant model will be parent-free</dd>
</dl>
<p>
	Method used to create a copy (similar to the clone method) of this model. This method is useful for only selecting certain attributes from this model.  If a parent is given, then the resultant model will have that parent rather than this model's parent. If 'null' is given for parent, then the resultant model will not have a parent.
</p>
		
	
		
			
			<h3 id="model-create">create
				<small>model.create( options )</small>
			</h3>
			<dl>
	<dt data-type="Object">options</dt>
	<dd>The options to pass into the 'sync' method</dd>
</dl>
<p>
	Method used to create a new model, with this model's data, on the server. This method is really just a wrapper around the 'sync' method with a request type of 'POST' auto-filled.
</p>
		
	
		
			
			<h3 id="model-destroy">destroy
				<small>model.destroy( options )</small>
			</h3>
			<dl>
	<dt data-type="Object">options</dt>
	<dd>The options to pass into the 'sync' method</dd>
</dl>
<p>
	Method used to delete this model from the server. This method just called 'sync' with the 'DELETE' request type pre-filled.
</p>
		
	
		
			
			<h3 id="model-equals">equals
				<small>model.equals( model )</small>
			</h3>
			<dl>
	<dt data-type="Falcon.Model">model</dt>
	<dd>A model to compare against this model. Models are compared using ids. If either or both IDs are 'null' then these models will always be unequal</dd>
</dl>
<dl>
	<dt data-type="String or Number">id</dt>
	<dd>An id to check against this model's id</dd>
</dl>
<p>
	Method used to determine if this model matches the given model or id. If any model as 'null' id then this method will always consider the result to be unequal.
</p>
		
	
		
			
			<h3 id="model-extend">extend
				<small>Falcon.Model.extend( properties )</small>
			</h3>
			<dl>
	<dt data-type="Object">properties</dt>
	<dd>The instance properties that should exist on the inheritting class</dd>
</dl>
<p>
	Method used to create a new model that inherits from the base Falcon Model.
</p>
		
	
		
			
			<h3 id="model-fetch">fetch
				<small>model.fetch( [options] )</small>
			</h3>
			<dl>
	<dt data-type="Object">options</dt>
	<dd>The options to pass into the 'sync' method</dd>
</dl>
<p>
	Method used to 'fetch' data from the server about this specific model. This method just called 'sync' with the 'GET' request type pre-filled.
</p>
		
	
		
			
			<h3 id="model-fill">fill
				<small>model.fill( data )</small>
			</h3>
			<dl>
	<dt data-type="Object">data</dt>
	<dd>The data to fill this object with.</dd>
</dl>
<p>
	Method used to fill this model with data. This is more advanced than the 'set' method as it won't overwrite certain data if it exists.  Specificaly this will recurse data into any Falcon Model of Collection 'fill' method as necessary. Additionally, this will put data into observables if a specific attribute identifies as a writeable observable. Lastly, this will do a basic assignment of a given attribute if it isn't a Falcon Data Object or an observable.

	Note: This method will, intentionally, ignore any attribute/method defined in the Falcon.Model.prototype except for 'id' and 'url'
</p>
		
	
		
			
			<h3 id="model-get">get
				<small>model.get( attribute )</small>
			</h3>
			<dl>
	<dt data-type="String">attribute</dt>
	<dd>The attribute to lookup</dd>
</dl>
<p>
	Method used to lookup the value of an attribute on this model. If the attribute is an observable, then the observable is unwrapped and its internal value is returned.
</p>
		
	
		
			
			<h3 id="model-id">id
				<small>model.id</small>
			</h3>
			<p>
	The id of this model. By default this is null unless it is set by the server. The id expected to be a Number or a String.
</p>
		
	
		
			
			<h3 id="model-isnew">isNew
				<small>model.isNew()</small>
			</h3>
			<p>
	Method used to determine if this model is 'new' or not. A model is deemed new if no id has been set (it's still null).
</p>
		
	
		
			
			<h3 id="model-makeurl">makeUrl
				<small>model.makeUrl( type, [parent] )</small>
			</h3>
			<dl>
	<dt data-type="String">type</dt>
	<dd>The type of request we're making (GET, POST, PUT, DELETE)</dd>
	<dt data-type="Falcon.Model">parent</dt>
	<dd>Optional override of the model's parent to generate the url with. If parent is 'null' then this model will act as the root node.</dd>
</dl>
<p>
	Generates a URL based on this model's url, the parent model of this model, the type of request we're making and Falcon's defined baseApiUrl
</p>
		
	
		
			
			<h3 id="model-mixin">mixin
				<small>model.mixin( mapping )</small>
			</h3>
			<dl>
	<dt data-bind="Object">mapping</dt>
	<dd>The mapping to augment this model with</dd>
</dl>
<p>
	Maps extra atributes and methods onto this model for use later, mostly in Falcon views. Will ensure that any method that is not a knockout observable will be called in the context of this model as well as pass this model in as the first argument, pushing the other arguments down the list.
</p>
		
	
		
			
			<h3 id="model-parent">parent
				<small>model.parent</small>
			</h3>
			<p>
	This represents the 'parent' object that holds this model.  Generally this is used for determining the URL structure of rest objects in the makeURL() routine. This should also be a Model.
</p>
		
	
		
			
			<h3 id="model-parse">parse
				<small>model.parse( data, [options], [xhr] )</small>
			</h3>
			<dl>
	<dt data-type="Object">data</dt>
	<dd>The raw response data</dd>
	<dt data-type="Object">options</dt>
	<dd>The options fed initially into the 'sync' request</dd>
	<dt data-type="XmlHttpRequest">xhr</dt>
	<dd>The XmlHttpRequest object</dd>
</dl>
<p>
	Parses the response data from an XmlHttpRequest request.  A json object must be returned from this method in order for the data to be filled back into the model.
</p>
		
	
		
			
			<h3 id="model-save">save
				<small>model.save( [options] )</small>
			</h3>
			<dl>
	<dt data-type-"Object">options</dt>
	<dd>Optional object of settings to use on this call.</dd>
</dl>
<p>
	Calls the sync method with 'PUT' as the default request type. Saves this model to the server.  If the model is new then 'create' will be called instead.
</p>
		
	
		
			
			<h3 id="model-serialize">serialize
				<small>model.serialize( [attributes] )</small>
			</h3>
			<dl>
	<dt>attributes</dt>
	<dd>
		The attributes that should be included in the serialization. If none given, all attributes from this model (except for functions) are serialized
	</dd>
</dl>
<p>
	Serializes the data into a raw json object and only corresponds to the attributes that are primitive and that we wish to be able to send back to the server.
</p>
<!--
	TODO:
	Expand on the attributes description
-->
		
	
		
			
			<h3 id="model-set">set
				<small>model.set( attribute, [value] )</small>
			</h3>
			<dl>
	<dt data-type="String">attribute</dt>
	<dd>The attribute to look up</dd>
	<dt>value</dt>
	<dd>The value to assign</dd>
</dl>
<dl>
	<dt data-type="Object">values</dt>
	<dd>An object of values to set</dd>
</dl>
<p>
	Sets a value for the specific attribute, creating one if it does nto exist.  If an object is passed into the first argument of this method, each of the object's key value pairs will be set on this model.
</p>
		
	
		
			
			<h3 id="model-sync">sync
				<small>model.sync( type, [options] )</small>
			</h3>
			<dl>
	<dt data-type="String">type</dt>
	<dd>The HTTP Method to call to the server with. Valid options options include "GET", "POST", "PUT", "DELETE".</dd>
	<dt data-type="Object">options</dt>
	<dd>Optional object of settings to use on this call.  This is usefull for configuring ajax callbacks, url parameters, fill paramaters, and attribute serialization handling. The avilable options are:
		<ul>
			<li>
				<strong>url</strong> - The url to make our request to. If the url isn't specified, then the 'makeUrl' method will be called with the given request type to generate a url.
			</li>
			<li>
				<strong>parent</strong> - An override of the parent object to use when generating a url with 'makeUrl'. If the parent option isn't set, then this model's parent is used.
			</li>
			<li>
				<strong>attributes</strong> - An object (or an array) of attributes to actually serialize and send to the server. This is the same attributes specifiation that will be passed into the 'serialize' method which is useful for reducing the load of data that is sent to the server.  See the 'serialize' method for more information on the attributes option.
			</li>
			<li>
				<strong>params</strong> - An object of query parameters to add to the request url.  This is useful for allowing the 'makeUrl' to generate a url for this model but still being able to add specific query parameters without having to modify the makeUrl method.
			</li>
			<li>
				<strong>data</strong> - An object of additional data to send through to the server.  This data is automatically JSON stringified if it is present and valid.  By default, this is set to the serialized version of this model with whatever attributes, if any, are specified in the 'attributes' parameter of the options object.
			</li>
			<li>
				<strong>dataType</strong> - The type of data to send to the server, the default is 'json'.
			</li>
			<li>
				<strong>headers</strong> - An object of HTTP headers to add to this request.
			</li>
			<li>
				<strong>context</strong> - The context to call the ajax callbacks (success, error, complete), on.
			</li>
			<li>
				<strong>success( model, data, status, xhr)</strong> - The callback that will be executed when the ajax request has completed with a 200 level response. The callback will be called on the context of this model unless the context option has been specified. The callback will be given four arguments: This model, the data after being passed through the parse method, the request status, and the XmlHttpRequest object.
			</li>
			<li>
				<strong>error( model, response, xhr )</strong> - A callback method to be executed whenever a 400 or above level response is returned from the server. This method will be called on the context of this model or the context given in the options if one is set.  This callback will be called with three arguments given: This model, the response text, and the XmlHttpRequest object. 
			<li>
				<strong>complete( model, xhr, status )</strong> - A callback method to be executed whenever any status resonse is completed. This method is called after success/error. It will be called on the context of this model unless the context was specified in the options. It will be called with three arguments given: This model, the XmlHttpRequest object, and the server status.
			</li>
			<li>
				<strong>fill</strong> - A flag to specify whether the 'fill' methos should be called once this request has completed successfully. By default, this is set to true.
			</li>
		</ul>
	</dd>
</dl>
<p>
	Method used to interact with the backend API and this model. This method utilizes and extend on to the jQuery $.ajax method.  This method may be called with for different request types:
	<ul>
		<li><strong>GET</strong> - Retrieve this model's data</li>
		<li><strong>POST</strong> - Create a model with this data on the server</li>
		<li><strong>PUT</strong> - Update this model's data on the server</li>
		<li><strong>DELETE</strong> - Delete this model from the server</li>
	</ul>
</p>
<p>
	The sync mehtod takes an optional 'options' argument which can be used for specifying how this method should hane sync requests of the request types mentioned and how it should handle serializing and reacting to success/errornous responses.
</p>
<p>
	If a PUT or POST request type or being issue, this model's 'validate' method is executed to check if this model is valid and if we should continue sending data to the server.  If the validate method returns false, the process is halted and no interaction with the server occurs
</p>
<p>
	Following the validation of the model, this method will automatically call the 'serialize' method on this model with whatever attributes, if any, are specified by the 'attributes' parameter of the options object if this is a POST or PUT request.  Please refer to the 'serialize' method for more advaned detail on how the 'attributes' option performs.
</p>
<p>
	Lastly, after the ajax method responds successfully, a success response will occur. Prior to calling the 'success' callback on the options, the raw data returned from the server will be send to the 'parse' method. The resultant data from the parse method is then sent to the 'fill' method (if the fill flag is enabled). Following that, an event is triggered depending on the request type.  (GET = 'fetch', POST = 'create', PUT = 'save', DELETE = 'destroy'). Lastly, the success callback method specified in the options parameter is called with this model as a conext, and with 4 arguments: This model, the parsed raw data, the response status, and the XmlHttpRequest object.
</p>
<!--
	TODO:
	Warning for no PATH support
	Warning for no jsonp
-->
		
	
		
			
			<h3 id="model-toggle">toggle
				<small>model.toggle( attribute )</small>
			</h3>
			<dl>
	<dt data-type="String">attribute</dt>
	<dd>The attribute in the model to look up.</dd>
</dl>
<p>
	Toggles the value between true/false on the specific attribute of this model.
</p>
		
	
		
			
			<h3 id="model-unwrap">unwrap
				<small>model.unwrap()</small>
			</h3>
			<p>
	Method used to 'unwrap' this model. Unwrapping makes this into a basic javascript object, recurring inward for other Falcon data objects (Collections and Models), and leaving observables and computed observables in tact in the resultant object.  This method is primarily used for creating clones of this model.
</p>
		
	
		
			
			<h3 id="model-url">url
				<small>model.url</small>
			</h3>
			<p>
	This is the top level url for the model.
</p>
		
	
		
			
			<h3 id="model-validate">validate
				<small>model.validate( [options] )</small>
			</h3>
			<dl>
	<dt data-type="Object">options</dt>
	<dd>The options passed into the sync method</dd>
</dl>
<p>
	Method used to validate this model before it is sent to the server on create or save.  If this method returns true, saving will continue but if it returns false then saving is halted and no request to the server will be made.
</p>
		
	
</section>




<section id="collection">
	<div class="page-header">
		<h1>Collection</h1>
	</div>
	
		
			
			<h3 id="collection-all">all
				<small>collection.all( [iterator] )</small>
			</h3>
			<dl>
	<dt data-type="Function">iterator</dt>
	<dd>An iterator to truth-test each model in the collection against</dd>
</dl>
<dl>
	<dt data-type="String or Number">id</dt>
	<dd>The id of models to match against in the collection</dd>
</dl>
<dl>
	<dt data-type="Falcon.Model">model</dt>
	<dd>A model to lookup in the collection</dd>
</dl>
<p>
	Method used to get an array of all the models that match the truth-test.
</p>
		
	
		
			
			<h3 id="collection-any">any
				<small>collection.any( iterator )</small>
			</h3>
			<dl>
	<dt data-type="Function">iterator</dt>
	<dd>Method used to test each model against.</dd>
</dl>
<dl>
	<dt data-type="String or Number">id</dt>
	<dd>The id to compare against each model in the collection.</dd>
</dl>
<dl>
	<dt data-type="Falcon.Model">model</dt>
	<dd>A model to compate against each of the collection's models using an id-based comparison.</dd>
</dl>
<p>
	Method used to check if any of the models in the collection match the given iterator, id, or model. Returns true if at least of the models match the truth test.
</p>
		
	
		
			
			<h3 id="collection-append">append
				<small>collection.append( items )</small>
			</h3>
			<dl>
	<dt data-type="Falcon.Model">item</dt>
	<dd>A model to add to the end of the collection</dd>
</dl>
<dl>
	<dt data-type="Array">items</dt>
	<dd>An array of models to add to the end of the collection</dd>
</dl>
<p>
	A a single or an array of models to the end of this collection. append is simply a wrapper for the full method with the option {'method': 'append'} pre-filled.
</p>
		
	
		
			
			<h3 id="collection-at">at
				<small>collection.at( index )</small>
			</h3>
			<dl>
	<dt data-type="Number">index</dt>
	<dd>zero-based index of the model to lookup in the collection</dd>
</dl>
<p>
	Method used to retrieve a model from this collection at a specific, zero-based, index. If no model exists at the specified inex, or the index is invalid, 'null' is returned.
</p>
		
	
		
			
			<h3 id="collection-clone">clone
				<small>collection.clone( parent )</small>
			</h3>
			<dl>
	<dt data-type="Falcon.Model">parent</dt>
	<dd>An optional parent to set in the resultant collection. If 'null' is set, then the resultant collection will be parent-free</dd>
</dl>
<p>
	This method does a shallow clone of this collection with the resultant collection containing the same model instances as the original collection. Optionally, if the parent argument is set, the resultant collection will reference that as its parent. If the parent argument is explicitly set to 'null' then the resultant collection will be parent-free.
</p>
		
	
		
			
			<h3 id="collection-initialize">initialize
				<small>new Falcon.Collection( [models], [parent] )</small>
			</h3>
			<dl>
	<dt data-type="Array">models</dt>
	<dd>An initial set of models to populate the collection with</dd>
	<dt data-type="Falcon.Model">parent</dt>
	<dd>The owner of this collection, used for generating urls when making requests to the server.</dd>
</dl>
<p>
	The constructor method for a Falcon Collection.  Creates a new instance of a Falcon Collection.
</p>
		
	
		
			
			<h3 id="collection-copy">copy
				<small>collection.copy( [attributes], [parent] )</small>
			</h3>
			<dl>
	<dt data-type="Object">attributes</dt>
	<dd>An object (or an array which will be converted to an object) of attributes to copy from each model in this collection. If this is not provided, only the id of each model is carried into the new collection.</dd>
	<dt data-type="Falcon.Model">parent</dt>
	<dd> An override of the parent to set in the resultant collection. If 'null' is explicitly given, then the resultant collection will be parent-free</dd>
</dl>
<p>
	Method used to create a copy (similar to the clone method) of this collection and it's models. This method is useful for only selecting certain attributes from each of the models in the collection.  If a parent is given, then the resultant collection will have that parent rather than this collection's parent. If 'null' is given for parent, then the resultant model will have no parent set.
</p>
		
	
		
			
			<h3 id="collection-create">create
				<small>collection.create( data, [options] )</small>
			</h3>
			<dl>
	<dt data-type="Object">data</dt>
	<dd>The raw data that defines the model to be created based on the collection's 'model' attribute.</dd>
	<dt data-type="Object">options</dt>
	<dd>The options to pass to the sync and fill methods.</dd>
</dl>
<dl>
	<dt data-type="Falcon.Model">data</dt>
	<dd>The model to create on the server and to add to this collection. This model's data will be unwrapped and a new model will be created in this collection if this argument is set.</dd>
	<dt data-type="Object">options</dt>
	<dd>See Above.</dd>
</dl>
<p>
	Method used to both create and add a model on the server and to this collection.  An optional options argument can be set to define options for the sync and fill methods.
</p>
		
	
		
			
			<h3 id="collection-destroy">destroy
				<small>collection.destroy( model, [options] )</small>
			</h3>
			<dl>
	<dt data-type="Falcon.Model">model</dt>
	<dd>The model to delete from the server and, upon successful delete, remove from this collection.</dd>
	<dt data-type="Object">options</dt>
	<dd>An optional set of options to pass into the 'sync' method when deleteing the model from the server</dd>
</dl>
<dl>
	<dt data-type="String or Integer">id</dt>
	<dd>The id of the model to remove</dd>
	<dt data-type="Object">options</dt>
	<dd>See Above</dd>
</dl>
<dl>
	<dt data-type="Function">iterator</dt>
	<dd>Iterator that can be used to find the first instance of a matching model in this collection.</dd>
	<dt data-type="Object">options</dt>
	<dd>See Above</dd>
</dl>
<p>
	Method used to both remove a model from this collection and delete it on the server. This method takes either an iterator, a model id, or a model to look up an existing model within this collection. If a model is given, it does not need to be the same instance of any model in this collection but rather an identical model based on its 'id'. If no models are found, then null is returned.  If the delete method from the server fails, this method does not remove anything from the collection.
</p>
		
	
		
			
			<h3 id="collection-each">each
				<small>collection.each( iterator, [context] )</small>
			</h3>
			<dl>
	<dt data-type="Function">iterator</dt>
	<dd>A function used to iterate over each model in this collection. The method will be called with each model passed in as the first argument and, optionally, the current index being as the second aguments.</dd>
	<dt data=type="mixed">context</dt>
	<dd>Optionally, the context to apply to the iterator</dd>
</dl>
<p>
	Iterates over each model in this collection based on a given iterator. For each model that exists in this collection, the iterator method is called with the model passed into the first argument and that model's index in the collection passed into the second argument.
</p>
		
	
		
			
			<h3 id="collection-extend">extend
				<small>Falcon.Collection.extend( definition )</small>
			</h3>
			<dl>
	<dt data-type="Object">definition</dt>
	<dd>The definition of the extending class' instance attributes and methods</dd>
</dl>
<p>Method used to create a new class that inherits from this class</p>
		
	
		
			
			<h3 id="collection-fetch">fetch
				<small>collection.fetch( [options] )</small>
			</h3>
			<dl>
	<dt data-type="Object">options</dt>
	<dd>The options to pass to the 'sync' method</dd>
</dl>
<p>
	Shorthand method to fetch ("GET") all of the models from the server. This method delegates its execution to the 'sync method'.
</p>
		
	
		
			
			<h3 id="collection-fill">fill
				<small>collection.fill( items, [options] )</small>
			</h3>
			<dl>
	<dt data-type="Array">items</dt>
	<dd>An array of models to add to the collection.</dd>
	<dt data-type="Object">options</dt>
	<dd>A hash of options to use when filling this collection with the given models. The 'method' attribute of options can be used to dictate how the models are added to this collection. The possible options are:
		<ul>
			<li>
				<strong>replace</strong> - Replaces all of the elements in the current list of models.
			</li>
			<li>
				<strong>append</strong> - Append the items to the end of the collection
			</li>
			<li>
				<strong>prepend</strong> - Prepend the items to the beginning of the collection
			</li>
			<li>
				<strong>merge</strong> - Update existing models in this collection (based on checking against models with matching 'id' attributes) and push any new items to the end of the collection.
			</li>
		</ul>
		by default, the 'replace' method is chosen.
	</dd>
</dl>
<dl>
	<dt data-type="Falcon.Model">item</dt>
	<dd>A model to add to the collection.</dd>
	<dt data-type="Object">options</dt>
	<dd>See Above</dd>
</dl>
<p>
	Method used to add new models to the collection. By default, this method just replaces all of the existing models in the collection. Optionally, one may define how models are added to the colleciton by defining the 'method' attribute of the options argument. 'method' can be either 'replace', 'append', 'prepend', or 'merge'. By default, 'replace' is chosen.
</p>
		
	
		
			
			<h3 id="collection-first">first
				<small>collection.first( [iterator] )</small>
			</h3>
			<dl>
	<dt data-type="Function">iterator</dt>
	<dd>A function to check each model in this collection against. If the iterator returns true then that model is selected.</dd>
</dl>
<p>
	Method used to obtain the first model in the collection. If an iterator is given, then each model starting from the beginning and moving towards the end of the collection, is tested. The first model to pass the truth test is returned. If no model could be found, then 'null' is returned.
</p>
		
	
		
			
			<h3 id="collection-last">last
				<small>collection.last( [iterator] )</small>
			</h3>
			<dl>
	<dt data-type="Function">iterator</dt>
	<dd>A function to check each model in this collection against. If the iterator returns true then that model is selected.</dd>
</dl>
<p>
	Method used to obtain the last model in the collection. If an iterator is given, then each model starting from the end and moving towards the beginning of the collection, is tested. The first model to pass the truth test is returned. If no model could be found, then 'null' is returned.
</p>
		
	
		
			
			<h3 id="collection-length">length
				<small>collection.length</small>
			</h3>
			<p>
	The total number of models in this collection. This is an observable so if being bound against, model additions/removals to this collectionwill cause any subscribed object to the length attribute to also be updated.
</p>
		
	
		
			
			<h3 id="collection-makeurl">makeUrl
				<small>collection.makeUrl( type, [parent] )</small>
			</h3>
			<dl>
	<dt data-type="String">type</dt>
	<dd>The type of request that is trying to be executed. Type can be either "GET", "POST", "PUT", "DELETE".</dd>
	<dt data-type="Falcon.Model">parent</dt>
	<dd>An override to the parent model of this collection. If 'null' is explicity stated, then no parent will be used meaning this collection's model prototype will be used to find the the base relative url for this request.</dd>
</dl>
<p>
	Attempts to generate url for a specific type of request being made. Url's are generated based on this collection's relative url (extracted from the collection's model prototype), the parent model for this collection, and the Falcon.baseApiUrl setting. 
</p>
<p>
	An optional override to the 'parent' attribute can be passed into the second argument of this method. If the parent argument is set, then that will be used instead of the instance parent attribute. Alternatively, if 'null' is explicitly set for the parent attribute, then this collection's url will be used as the base url for the full url generation.
</p>
		
	
		
			
			<h3 id="collection-mixin">mixin
				<small>collection.mixin( mapping )</small>
			</h3>
			<dl>
	<dt data-type="Object">mapping</dt>
	<dd>The mapping to apply to each of the current models and any future models that are added to the collection.</dd>
</dl>
<p>
	Adds attributes and functions to all of the current and future models in the collection.  This is especially useful for adding one-off functions or observables where needed on each item in the collection that isn't really necessary for everytime this specific collection is created. A good example of this would be adding a 'deleteing' flag to each current and future model in the collection to signify if the model is currently being deleted (hence allowing us to show a loader and ignore any additional delete requests).
</p>
		
	
		
			
			<h3 id="collection-model">model
				<small>collection.model</small>
			</h3>
			<p>
	The prototype of the model of each item in this collection. This is used to ensure that all models within this collection are the correct type. It is also used to determine the relative url for models in this collection when making sync requests to the server.
</p>
		
	
		
			
			<h3 id="collection-models">models
				<small>collection.models</small>
			</h3>
			<p>
	The internal observable array that contains all of the models added to this collection.
</p>
		
	
		
			
			<h3 id="collection-parent">parent
				<small>collection.parent</small>
			</h3>
			<p>
	This represents the 'parent' object that holds these models.  Generally this is used for determining the URL structure of rest objects in the makeURL() routine. This should also be a Model.
</p>
		
	
		
			
			<h3 id="collection-parse">parse
				<small>collection.parse( data, options, xhr )</small>
			</h3>
			<dl>
	<dt data-type='Object'>data</dt>
	<dd>The raw data returned from the server</dd>
	<dt data-type='Object'>options</dt>
	<dd>The options that were passed into the sync function</dd>
	<dt data-type="XmlHttpRequest">xhr</dt>
	<dd>The XmlHttpRequest that was created when making this request</dd>
</dl>
<p>
	The parse method is called after any successful request is completed but before any of the data is actually filled into the collection. It's purpose is to allow you to intercept and parse through the raw server data in order to format it correctly to how this collection expects to see it. This method must return an array of objects in order for the collection to be filled correctly.
</p>
		
	
		
			
			<h3 id="collection-pluck">pluck
				<small>collection.pluck( attribute, [unwrap] )</small>
			</h3>
			<dl>
	<dt data-type="String">attribute</dt>
	<dd>The attribute to pluck from each model in the collecton</dd>
	<dt data-type="Boolean" data-default="true">unwrap</dt>
	<dd>Flag that states if we should unwrap the values that are observables.</dd>
</dl>
<p>
	This method extracts a specific attribute from each model in the collection and returns it in an array. If the unwrap flag is set to true (which it is by default), each attribute is removed from its observable container if it exists wihin one.  If the attribute given isn't found in a model, 'undefined' is returned in the resultant array.
</p>
		
	
		
			
			<h3 id="collection-pop">pop
				<small>collection.pop()</small>
			</h3>
			<p>
	Removes and returns the last model from this collection.  If this collection is empty, 'null' is returned instead.
</p>
		
	
		
			
			<h3 id="collection-prepend">prepend
				<small>collection.prepend( items )</small>
			</h3>
			<dl>
	<dt type="Falcon.Model">item</dt>
	<dd>A model to prepend to the beginning of this colleciton.</dd>
</dl>
<dl>
	<dt type="Array">items</dt>
	<dd>An array of models to prepend to the beginning of this colleciton.</dd>
</dl>
<p>
	Adds a model or an array of models to the beginning of this collection.
</p>
		
	
		
			
			<h3 id="collection-push">push
				<small>collection.push( items )</small>
			</h3>
			<dl>
	<dt type="Falcon.Model">item</dt>
	<dd>A model to add to the colleciton</dd>
</dl>
<p>
	Push an element on to the end of this collection. This method is an alias od append.
</p>
		
	
		
			
			<h3 id="collection-remove">remove
				<small>collection.remove( items )</small>
			</h3>
			<dl>
	<dt data-type="Array">items</dt>
	<dd>An array of models to remove from this colleciton.</dd>
</dl>
<dl>
	<dt data-type="Falcon.Model">item</dt>
	<dd>An item to remove from this collection.</dd>
</dl>
<dl>
	<dt data-type="Function">iterator</dt>
	<dd>An iterator function to compare each model in this collection against. If the iterator is true, then the model is removed.</dd>
</dl>
<p>
	Used to remove elements from this collection. This method does not make any API delete requests and will simply remove an instance of a model from this collection.
</p>
		
	
		
			
			<h3 id="collection-reset">reset
				<small>collection.reset()</small>
			</h3>
			<p>
	'resets' the internal observable array of this collection. This will make sure the model list is an observable array, has no elements, and the length of the collection is restored to zero.
</p>
		
	
		
			
			<h3 id="collection-serialize">serialize
				<small>collection.serialize( [attributes] )</small>
			</h3>
			<dl>
	<dt data-type="Array">attributes</dt>
	<dd>The attributes that should be included in the serialization of each model in this collection. If none given, all attributes unique to each model is included.</dd>
</dl>
		
	
		
			
			<h3 id="collection-shift">shift
				<small>collection.shift()</small>
			</h3>
			<p>
	Removes the first element from the models and returns it.
</p>
		
	
		
			
			<h3 id="collection-slice">slice
				<small>collection.slice( start, [end] )</small>
			</h3>
			<dl>
	<dt>start</dt>
	<dd>An integer that specifies where to start the selection (The first element has an index of 0).  Use negative numbers to select from the end of an array.</dd>
	<dt>end</dt>
	<dd>An integer that specifies where to end the selection.  If omitted, all elements from the start position and to the end of the array will be selected. Use negative numbers to select from the end of an array</dd>
</dl>
<p>
	Slices the underlying collection the same way slice works on an array.
</p>
		
	
		
			
			<h3 id="collection-sort">sort
				<small>collection.sort( sorter )</small>
			</h3>
			<dl>
	<dt>sorter</dt>
	<dd>An iterator to sort the collection with.</dd>
</dl>
<p>
	Sorts the collection by a given sorter function.
</p>
		
	
		
			
			<h3 id="collection-sync">sync
				<small>collection.sync( type, [options] )</small>
			</h3>
			<dl>
	<dt>type</dt>
	<dd>The HTTP Method to call to the server with</dd>
	<dt>options</dt>
	<dd>Optional object of settings to use on this call</dd>
</dl>
<p>
	Used to dynamically place calls to the server in order to create, update, destroy, or read this from/to the server.
</p>
		
	
		
			
			<h3 id="collection-unshift">unshift
				<small>collection.unshift( items )</small>
			</h3>
			<!--
	TODO: Link to prepend
-->
<dl>
	<dt>items</dt>
	<dd>A list of models to add to the collection</dd>
</dl>
<dl>
	<dt>item</dt>
	<dd>A model to add to the collection</dd>
</dl>
<p>
	Push an element onto the begining of the array, Alias of prepend.
</p>
		
	
		
			
			<h3 id="collection-unwrap">unwrap
				<small>collection.unwrap()</small>
			</h3>
			<p>
	Method used to 'unwrap' this object into an anonymous object Needed to cascade inwards on other Falcon Data objects (like models) to unwrap newly added member variables/objects
</p>
		
	
		
			
			<h3 id="collection-url">url
				<small>collection.url</small>
			</h3>
			<p>This is the top level url for the collection.</p>
		
	
		
			
			<h3 id="collection-without">without
				<small>collection.without( iterator )</small>
			</h3>
			<dl>
	<dt>iterator</dt>
	<dd>The iterator to check each model against</dd>
</dl>
<p>Returns an array of elements that don't match the iterator</p>
		
	
</section>




<section id="view">
	<div class="page-header">
		<h1>View</h1>
	</div>
	
		
			
			<h3 id="view-addchildview">addChildView
				<small>Falcon.View#addChildView</small>
			</h3>
			Waiting for Description
		
	
		
			
			<h3 id="view-cachetemplate">cacheTemplate
				<small>Falcon.View.cacheTemplate( identifier, template )</small>
			</h3>
			Waiting for Description
		
	
		
			
			<h3 id="view-initialize">initialize
				<small>new Falcon.View()</small>
			</h3>
			Waiting for Description
		
	
		
			
			<h3 id="view-display">display
				<small>Falcon.View#display()</small>
			</h3>
			Waiting for Description
		
	
		
			
			<h3 id="view-dispose">dispose
				<small>Falcon.View#dispose()</small>
			</h3>
			Waiting for Description
		
	
		
			
			<h3 id="view-is_loaded">is_loaded
				<small>Falcon.View#is_loaded</small>
			</h3>
			Waiting for Description
		
	
		
			
			<h3 id="view-makeurl">makeUrl
				<small>Falcon.View#makeUrl</small>
			</h3>
			Waiting for Description
		
	
		
			
			<h3 id="view-render">render
				<small>Falcon.View#render()</small>
			</h3>
			Waiting for Description
		
	
		
			
			<h3 id="view-resetcache">resetCache
				<small>Falcon.View.resetCache()</small>
			</h3>
			Waiting for Description
		
	
		
			
			<h3 id="view-template">template
				<small>Falcon.View#template()</small>
			</h3>
			Waiting for Description
		
	
		
			
			<h3 id="view-unrender">unrender
				<small>Falcon.View#unrender()</small>
			</h3>
			Waiting for Description
		
	
		
			
			<h3 id="view-url">url
				<small>Falcon.View#url</small>
			</h3>
			Waiting for Description
		
	
		
			
			<h3 id="view-viewmodel">viewModel
				<small>Falcon.View#viewModel</small>
			</h3>
			Waiting for Description
		
	
</section>




<section id="helpers">
	<div class="page-header">
		<h1>Helpers</h1>
	</div>
	
		
			
			<h3 id="helpers-addbinding">addBinding
				<small>Falcon.addBinding( name, definition, [allowVirtual] )</small>
			</h3>
			Waiting for Description
		
	
		
			
			<h3 id="helpers-apply">apply
				<small>Falcon.apply( root, [element], [callback] )</small>
			</h3>
			Waiting for Description
		
	
		
			
			<h3 id="helpers-iscollection">isCollection
				<small>Falcon.isCollection( object )</small>
			</h3>
			Waiting for Description
		
	
		
			
			<h3 id="helpers-isdataobject">isDataObject
				<small>Falcon.isDataObject( object )</small>
			</h3>
			Waiting for Description
		
	
		
			
			<h3 id="helpers-isfalconobject">isFalconObject
				<small>Falcon.isFalconObject( object )</small>
			</h3>
			Waiting for Description
		
	
		
			
			<h3 id="helpers-ismodel">isModel
				<small>Falcon.isModel( object )</small>
			</h3>
			Waiting for Description
		
	
		
			
			<h3 id="helpers-isview">isView
				<small>Falcon.isView( object )</small>
			</h3>
			Waiting for Description
		
	
</section>




<section id="bindings">
	<div class="page-header">
		<h1>Bindings</h1>
	</div>
	
		
			
			<h3 id="bindings-foreach">foreach
				<small></small>
			</h3>
			<p>This is the same as the <a href="http://knockoutjs.com/documentation/foreach-binding.html" alt="Knockout's Foreach binding">Knockout's Foreach binding</a> except that it has been modified to handle Falcon Collection's as well</p>
		
	
		
			
			<h3 id="bindings-log">log
				<small></small>
			</h3>
			<p>This is a helper binding that can be used to dump whatever is passed into it, into the browser console. Useful for debugging and understanding context</p>
		
	
		
			
			<h3 id="bindings-options">options
				<small></small>
			</h3>
			<p>This is the same as the <a href="http://knockoutjs.com/documentation/options-binding.html" alt="Knockout's Options binding">Knockout's Options binding</a> except that it has been modified to handle Falcon Collection's as well.</p>
		
	
		
			
			<h3 id="bindings-view">view
				<small></small>
			</h3>
			<p>Method used to handle Falcon.View obects. This will handle fetching a view's viewmodel and html template.  This method expects to use the native Knockout templating engine.</p>
		
	
</section>
				</div>
			</div>
		</div>
		<div id="footer" class="container">
		</div>
		<script src="scripts/jquery-1.10.0.min.js"></script>
		<script src="scripts/bootstrap.min.js"></script>
		<script src="scripts/falcon.docs.min.js"></script>
	</body>
</html>